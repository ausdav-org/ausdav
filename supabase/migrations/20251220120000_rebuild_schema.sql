begin;

--------------------------------------------------------------------------------
-- 0) CLEANUP (safe re-run)
--------------------------------------------------------------------------------

-- Drop insecure legacy table if it exists (we use Supabase Auth instead)
-- drop table if exists public.auth_member cascade;

-- -- If you previously had finance_overview as a TABLE or VIEW, drop both safely
-- drop view  if exists public.finance_overview cascade;
-- drop table if exists public.finance_overview cascade;

-- -- Drop public schema policies (so script can be re-run safely)
-- do $$
-- declare
--   r record;
-- begin
--   for r in
--     select schemaname, tablename, policyname
--     from pg_policies
--     where schemaname = 'public'
--       and tablename in (
--         'announcements','events','past_papers','seminars',
--         'feedbacks','applicants',
--         'finance',
--         'members','permissions'
--       )
--   loop
--     execute format('drop policy if exists %I on %I.%I;', r.policyname, r.schemaname, r.tablename);
--   end loop;
-- end $$;

-- -- Drop Storage policies we create (safe re-run)
-- drop policy if exists announcements_assets_read    on storage.objects;
-- drop policy if exists announcements_assets_insert  on storage.objects;
-- drop policy if exists announcements_assets_update  on storage.objects;
-- drop policy if exists announcements_assets_delete  on storage.objects;

-- drop policy if exists past_papers_assets_read      on storage.objects;
-- drop policy if exists past_papers_assets_insert    on storage.objects;
-- drop policy if exists past_papers_assets_update    on storage.objects;
-- drop policy if exists past_papers_assets_delete    on storage.objects;

-- drop policy if exists seminars_assets_read         on storage.objects;
-- drop policy if exists seminars_assets_insert       on storage.objects;
-- drop policy if exists seminars_assets_update       on storage.objects;
-- drop policy if exists seminars_assets_delete       on storage.objects;

-- drop policy if exists finance_photos_read          on storage.objects;
-- drop policy if exists finance_photos_insert        on storage.objects;
-- drop policy if exists finance_photos_update        on storage.objects;
-- drop policy if exists finance_photos_delete        on storage.objects;

-- drop policy if exists member_profiles_read         on storage.objects;
-- drop policy if exists member_profiles_insert       on storage.objects;
-- drop policy if exists member_profiles_update       on storage.objects;
-- drop policy if exists member_profiles_delete       on storage.objects;

--------------------------------------------------------------------------------
-- 0.5) SUPABASE STORAGE BUCKETS (idempotent)
-- Public buckets: past-papers, seminars, announcements
-- Private buckets: finance-photos, member-profiles
--------------------------------------------------------------------------------

insert into storage.buckets (id, name, public)
values
  ('past-papers',     'past-papers',     true),
  ('seminars',        'seminars',        true),
  ('announcements',   'announcements',   true),
  ('finance-photos',  'finance-photos',  false),
  ('member-profiles', 'member-profiles', false)
on conflict (id) do update
set name   = excluded.name,
    public = excluded.public;

--------------------------------------------------------------------------------
-- 1) TYPES (ENUMS)
--------------------------------------------------------------------------------

do $$
begin
  if not exists (
    select 1
    from pg_type t
    join pg_namespace n on n.oid = t.typnamespace
    where n.nspname = 'public'
      and t.typname = 'finance_direction'
  ) then
    execute 'create type public.finance_direction as enum (''income'',''expense'')';
  end if;

  if not exists (
    select 1
    from pg_type t
    join pg_namespace n on n.oid = t.typnamespace
    where n.nspname = 'public'
      and t.typname = 'finance_party_role'
  ) then
    execute 'create type public.finance_party_role as enum (''payer'',''payee'')';
  end if;
end $$;



--------------------------------------------------------------------------------
-- 2) TABLES
--------------------------------------------------------------------------------

-- announcements
create table if not exists public.announcements (
  announcement_id integer generated by default as identity primary key,
  category text not null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  title text not null,
  description text not null,

  -- Supabase Storage pattern
  img_bucket text not null default 'announcements',
  img_path text null
);

-- feedbacks
create table if not exists public.feedbacks (
  feed_id integer generated by default as identity primary key,
  created_at timestamptz not null default now(),
  message text not null
);

-- applicants
create table if not exists public.applicants (
  applicant_id integer generated by default as identity primary key,
  index_no text not null,
  fullname text not null,
  gender boolean not null,  -- convention: TRUE=male, FALSE=female (document in your app)
  stream text not null,
  nic varchar(12) not null,
  phone varchar(10),
  email text,
  school text not null,
  results text null,
  created_at timestamptz not null default now()
);

-- past_papers
create table if not exists public.past_papers (
  pp_id integer generated by default as identity primary key,
  yrs integer not null,
  subject text not null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),

  -- Supabase Storage pattern
  file_bucket text not null default 'past-papers',
  file_path text null,
  mime_type text not null default 'application/pdf',
  file_size bigint null
);

-- seminars
create table if not exists public.seminars (
  sem_id integer generated by default as identity primary key,
  yrs integer not null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),

  -- Supabase Storage pattern
  file_bucket text not null default 'seminars',
  file_path text null,
  mime_type text not null default 'application/pdf',
  file_size bigint null
);

-- events
create table if not exists public.events (
  eve_id integer generated by default as identity primary key,
  title text not null,
  year integer not null,
  description text not null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

-- members (AUTH REDESIGN + PROFILE PIC SUPPORT)
create table if not exists public.members (
  mem_id integer generated by default as identity primary key,
  fullname text not null,
  username text not null,
  nic varchar(12) not null,
  gender boolean not null,
  role text not null,
  batch integer not null,
  university text not null,
  school text not null,
  phone varchar(20) not null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  designation text not null,
  auth_user_id uuid null,

  -- profile picture (Supabase Storage pattern)
  profile_bucket text not null default 'member-profiles',
  profile_path text null
);

-- finance
create table if not exists public.finance (
  fin_id integer generated by default as identity primary key,

  exp_type public.finance_direction not null,        -- income/expense
  party_role public.finance_party_role not null,     -- payer/payee

  category text not null,
  amount numeric(12,2) not null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  description text not null,

  -- Supabase Storage pattern
  photo_bucket text not null default 'finance-photos',
  photo_path text null,

  approved boolean not null default false
);

-- permissions (one-to-one with members via FK)
create table if not exists public.permissions (
  id integer primary key, -- members.mem_id
  announcement boolean not null default false,
  events boolean not null default false,
  finance boolean not null default false,
  member boolean not null default false,
  paper_seminar boolean not null default false,
  applicant boolean not null default false
);

--------------------------------------------------------------------------------
-- 2.5) NON-DESTRUCTIVE MIGRATIONS (for existing tables)
--------------------------------------------------------------------------------

alter table public.announcements
  add column if not exists updated_at timestamptz not null default now(),
  add column if not exists img_bucket text not null default 'announcements',
  add column if not exists img_path text null;

alter table public.past_papers
  add column if not exists created_at timestamptz not null default now(),
  add column if not exists updated_at timestamptz not null default now(),
  add column if not exists file_bucket text not null default 'past-papers',
  add column if not exists file_path text null,
  add column if not exists mime_type text not null default 'application/pdf',
  add column if not exists file_size bigint null;

alter table public.seminars
  add column if not exists created_at timestamptz not null default now(),
  add column if not exists updated_at timestamptz not null default now(),
  add column if not exists file_bucket text not null default 'seminars',
  add column if not exists file_path text null,
  add column if not exists mime_type text not null default 'application/pdf',
  add column if not exists file_size bigint null;

alter table public.events
  add column if not exists created_at timestamptz not null default now(),
  add column if not exists updated_at timestamptz not null default now();

alter table public.members
  add column if not exists updated_at timestamptz not null default now(),
  add column if not exists auth_user_id uuid null,
  add column if not exists profile_bucket text not null default 'member-profiles',
  add column if not exists profile_path text null;

alter table public.finance
  add column if not exists updated_at timestamptz not null default now(),
  add column if not exists photo_bucket text not null default 'finance-photos',
  add column if not exists photo_path text null;

-- Make legacy URL fields nullable (if they exist in older versions)
do $$
begin
  begin alter table public.announcements alter column img drop not null; exception when undefined_column then null; end;
  begin alter table public.past_papers  alter column url drop not null; exception when undefined_column then null; end;
  begin alter table public.seminars     alter column url drop not null; exception when undefined_column then null; end;
  begin alter table public.finance      alter column photo drop not null; exception when undefined_column then null; end;
end $$;

-- Ensure finance.amount is numeric(12,2) (safe if it already is)
do $$
begin
  begin
    alter table public.finance
      alter column amount type numeric(12,2) using amount::numeric;
  exception when others then
    null;
  end;
end $$;

--------------------------------------------------------------------------------
-- 3) CONSTRAINTS + INDEXES
--------------------------------------------------------------------------------

-- members.auth_user_id -> auth.users(id)
do $$
begin
  if not exists (
    select 1 from pg_constraint where conname = 'members_auth_user_id_fkey'
  ) then
    alter table public.members
      add constraint members_auth_user_id_fkey
      foreign key (auth_user_id) references auth.users(id)
      on delete set null;
  end if;
end $$;

-- permissions.id -> members.mem_id
do $$
begin
  if not exists (
    select 1 from pg_constraint where conname = 'permissions_id_fkey'
  ) then
    alter table public.permissions
      add constraint permissions_id_fkey
      foreign key (id) references public.members(mem_id)
      on update cascade
      on delete cascade;
  end if;
end $$;

-- Uniqueness
create unique index if not exists members_username_uniq on public.members(username);
create unique index if not exists members_nic_uniq on public.members(nic);
create unique index if not exists members_auth_user_id_uniq
  on public.members(auth_user_id)
  where auth_user_id is not null;

--------------------------------------------------------------------------------
-- 4) SUPER ADMIN SINGLETON + PERMISSION HELPERS (for RLS)
--------------------------------------------------------------------------------

create schema if not exists private;

create table if not exists private.app_config (
  id int primary key default 1,
  super_admin_id uuid null,
  constraint app_config_singleton check (id = 1)
);

insert into private.app_config (id, super_admin_id)
values (1, null)
on conflict (id) do nothing;

create or replace function private.is_super_admin()
returns boolean
language sql
stable
security definer
set search_path = ''
as $$
  select exists (
    select 1
    from private.app_config c
    where c.id = 1
      and c.super_admin_id = auth.uid()
  );
$$;

create or replace function private.bootstrap_super_admin(p_user_id uuid)
returns void
language plpgsql
security definer
set search_path = ''
as $$
begin
  if auth.role() <> 'service_role' then
    raise exception 'forbidden';
  end if;

  update private.app_config
     set super_admin_id = p_user_id
   where id = 1
     and super_admin_id is null;

  if not found then
    raise exception 'super admin already set';
  end if;
end;
$$;

-- CHANGE #1: Public wrapper so you can call it from Postman (RPC) without exposing the private schema
create or replace function public.bootstrap_super_admin(p_user_id uuid)
returns void
language plpgsql
security definer
set search_path = ''
as $$
begin
  perform private.bootstrap_super_admin(p_user_id);
end;
$$;

revoke all on function public.bootstrap_super_admin(uuid) from anon, authenticated;
grant execute on function public.bootstrap_super_admin(uuid) to service_role;

create or replace function private.current_member_id()
returns integer
language sql
stable
security definer
set search_path = ''
as $$
  select m.mem_id
  from public.members m
  where m.auth_user_id = auth.uid()
  limit 1;
$$;

create or replace function private.has_permission(p_perm text)
returns boolean
language sql
stable
security definer
set search_path = ''
as $$
  select coalesce((
    select case p_perm
      when 'announcement'   then p.announcement
      when 'events'         then p.events
      when 'finance'        then p.finance
      when 'member'         then p.member
      when 'paper_seminar'  then p.paper_seminar
      when 'applicant'      then p.applicant
      else false
    end
    from public.permissions p
    where p.id = (select private.current_member_id())
    limit 1
  ), false);
$$;

-- updated_at helper trigger
create or replace function private.tg_set_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at := now();
  return new;
end;
$$;

-- MEMBERS: restrict non-admin updates to profile fields only + set updated_at
create or replace function private.tg_members_before_update()
returns trigger
language plpgsql
security definer
set search_path = ''
as $$
begin
  new.updated_at := now();

  -- admins can update anything
  if private.is_super_admin() or private.has_permission('member') then
    return new;
  end if;

  -- non-admin: must be updating own row
  if old.auth_user_id is distinct from auth.uid() then
    raise exception 'forbidden';
  end if;

  -- non-admin: block changes to all non-profile fields
  if new.mem_id        is distinct from old.mem_id        then raise exception 'forbidden'; end if;
  if new.fullname      is distinct from old.fullname      then raise exception 'forbidden'; end if;
  if new.username      is distinct from old.username      then raise exception 'forbidden'; end if;
  if new.nic           is distinct from old.nic           then raise exception 'forbidden'; end if;
  if new.gender        is distinct from old.gender        then raise exception 'forbidden'; end if;
  if new.role          is distinct from old.role          then raise exception 'forbidden'; end if;
  if new.batch         is distinct from old.batch         then raise exception 'forbidden'; end if;
  if new.university    is distinct from old.university    then raise exception 'forbidden'; end if;
  if new.school        is distinct from old.school        then raise exception 'forbidden'; end if;
  if new.phone         is distinct from old.phone         then raise exception 'forbidden'; end if;
  if new.created_at    is distinct from old.created_at    then raise exception 'forbidden'; end if;
  if new.designation   is distinct from old.designation   then raise exception 'forbidden'; end if;
  if new.auth_user_id  is distinct from old.auth_user_id  then raise exception 'forbidden'; end if;

  -- allowed for non-admin: profile_bucket, profile_path, updated_at
  return new;
end;
$$;

-- Lock down private schema objects (no direct table access)
revoke all on schema private from anon, authenticated;
revoke all on all tables in schema private from anon, authenticated;

-- Allow calling helper functions from RLS
grant usage on schema private to anon, authenticated;
grant execute on function private.is_super_admin() to anon, authenticated;
grant execute on function private.current_member_id() to anon, authenticated;
grant execute on function private.has_permission(text) to anon, authenticated;
-- DO NOT grant execute on private.bootstrap_super_admin()

--------------------------------------------------------------------------------
-- 4.5) FINANCE OVERVIEW VIEW (replaces singleton table)
-- Returns 0 rows if caller is not finance-permitted (via HAVING)
--------------------------------------------------------------------------------

create or replace view public.finance_overview
with (security_invoker = true)
as
select
  1 as id,
  coalesce(sum(amount) filter (where exp_type = 'income'::public.finance_direction), 0)::numeric(12,2) as income,
  coalesce(sum(amount) filter (where exp_type = 'expense'::public.finance_direction), 0)::numeric(12,2) as expense,
  (
    coalesce(sum(amount) filter (where exp_type = 'income'::public.finance_direction), 0)
    -
    coalesce(sum(amount) filter (where exp_type = 'expense'::public.finance_direction), 0)
  )::numeric(12,2) as balance
from public.finance
having private.is_super_admin() or private.has_permission('finance');

--------------------------------------------------------------------------------
-- 5) UPDATED_AT TRIGGERS
--------------------------------------------------------------------------------

drop trigger if exists set_updated_at_announcements on public.announcements;
create trigger set_updated_at_announcements
before update on public.announcements
for each row execute function private.tg_set_updated_at();

drop trigger if exists set_updated_at_events on public.events;
create trigger set_updated_at_events
before update on public.events
for each row execute function private.tg_set_updated_at();

drop trigger if exists set_updated_at_past_papers on public.past_papers;
create trigger set_updated_at_past_papers
before update on public.past_papers
for each row execute function private.tg_set_updated_at();

drop trigger if exists set_updated_at_seminars on public.seminars;
create trigger set_updated_at_seminars
before update on public.seminars
for each row execute function private.tg_set_updated_at();

drop trigger if exists set_updated_at_finance on public.finance;
create trigger set_updated_at_finance
before update on public.finance
for each row execute function private.tg_set_updated_at();

drop trigger if exists members_before_update on public.members;
create trigger members_before_update
before update on public.members
for each row execute function private.tg_members_before_update();

--------------------------------------------------------------------------------
-- 6) GRANTS (RLS still decides row access)
--------------------------------------------------------------------------------

-- Public read content
grant select on public.announcements, public.events, public.past_papers, public.seminars
to anon, authenticated;

-- Public submit
grant insert on public.feedbacks, public.applicants
to anon, authenticated;

-- Allow admins (authenticated) to read/manage feedbacks/applicants (RLS will restrict)
grant select on public.feedbacks, public.applicants to authenticated;
grant update, delete on public.feedbacks, public.applicants to authenticated;

-- Authenticated operational access (still constrained by RLS)
grant select, insert, update, delete on
  public.announcements, public.events, public.past_papers, public.seminars,
  public.finance, public.members, public.permissions
to authenticated;

-- View: select only
grant select on public.finance_overview to authenticated;

-- CHANGE #2: Storage table privileges (RLS policies alone are not enough)
grant select on storage.objects to anon, authenticated;
grant insert, update, delete on storage.objects to authenticated;

--------------------------------------------------------------------------------
-- 7) ENABLE + FORCE RLS (tables only; views do not support RLS)
--------------------------------------------------------------------------------

alter table public.announcements enable row level security;
alter table public.events        enable row level security;
alter table public.past_papers   enable row level security;
alter table public.seminars      enable row level security;
alter table public.feedbacks     enable row level security;
alter table public.applicants    enable row level security;
alter table public.finance       enable row level security;
alter table public.members       enable row level security;
alter table public.permissions   enable row level security;

-- Strongly recommended for sensitive tables
alter table public.finance      force row level security;
alter table public.members      force row level security;
alter table public.permissions  force row level security;

--------------------------------------------------------------------------------
-- 8) TABLE RLS POLICIES
--------------------------------------------------------------------------------

-- announcements: public read; write by super admin OR announcement permission
create policy announcements_read_public
on public.announcements
for select
to anon, authenticated
using (true);

create policy announcements_write
on public.announcements
for all
to authenticated
using ( private.is_super_admin() or private.has_permission('announcement') )
with check ( private.is_super_admin() or private.has_permission('announcement') );

-- events: public read; write by super admin OR events permission
create policy events_read_public
on public.events
for select
to anon, authenticated
using (true);

create policy events_write
on public.events
for all
to authenticated
using ( private.is_super_admin() or private.has_permission('events') )
with check ( private.is_super_admin() or private.has_permission('events') );

-- past_papers: public read; write by super admin OR paper_seminar permission
create policy past_papers_read_public
on public.past_papers
for select
to anon, authenticated
using (true);

create policy past_papers_write
on public.past_papers
for all
to authenticated
using ( private.is_super_admin() or private.has_permission('paper_seminar') )
with check ( private.is_super_admin() or private.has_permission('paper_seminar') );

-- seminars: public read; write by super admin OR paper_seminar permission
create policy seminars_read_public
on public.seminars
for select
to anon, authenticated
using (true);

create policy seminars_write
on public.seminars
for all
to authenticated
using ( private.is_super_admin() or private.has_permission('paper_seminar') )
with check ( private.is_super_admin() or private.has_permission('paper_seminar') );

-- feedbacks: anyone can insert; only super admin or member permission can read
create policy feedbacks_insert_public
on public.feedbacks
for insert
to anon, authenticated
with check (true);

create policy feedbacks_read_admin
on public.feedbacks
for select
to authenticated
using ( private.is_super_admin() or private.has_permission('member') );

-- applicants: anyone can insert; only super admin or applicant permission can manage
create policy applicants_insert_public
on public.applicants
for insert
to anon, authenticated
with check (true);

create policy applicants_manage
on public.applicants
for all
to authenticated
using ( private.is_super_admin() or private.has_permission('applicant') )
with check ( private.is_super_admin() or private.has_permission('applicant') );

-- finance: super admin OR finance permission can read
create policy finance_read
on public.finance
for select
to authenticated
using ( private.is_super_admin() or private.has_permission('finance') );

-- finance insert: finance permission can insert but cannot auto-approve
create policy finance_insert
on public.finance
for insert
to authenticated
with check (
  private.is_super_admin()
  or (private.has_permission('finance') and approved = false)
);

-- finance update: finance permission can update only while approved=false; super admin can update any
create policy finance_update_draft
on public.finance
for update
to authenticated
using ( private.has_permission('finance') and approved = false )
with check ( private.has_permission('finance') and approved = false );

create policy finance_update_admin
on public.finance
for update
to authenticated
using ( private.is_super_admin() )
with check ( private.is_super_admin() );

create policy finance_delete_admin
on public.finance
for delete
to authenticated
using ( private.is_super_admin() );

-- members: read own row; admin/member permission can read all
create policy members_read
on public.members
for select
to authenticated
using (
  auth_user_id = auth.uid()
  or private.is_super_admin()
  or private.has_permission('member')
);

-- members: admins can manage everything
create policy members_manage_admin
on public.members
for all
to authenticated
using ( private.is_super_admin() or private.has_permission('member') )
with check ( private.is_super_admin() or private.has_permission('member') );

-- members: normal users can update their own row (trigger restricts to profile fields)
create policy members_update_self
on public.members
for update
to authenticated
using ( auth_user_id = auth.uid() )
with check ( auth_user_id = auth.uid() );

-- permissions: user can read own permissions; only super admin can write
create policy permissions_read_self
on public.permissions
for select
to authenticated
using (
  id = private.current_member_id()
  or private.is_super_admin()
);

create policy permissions_write_admin
on public.permissions
for all
to authenticated
using ( private.is_super_admin() )
with check ( private.is_super_admin() );

--------------------------------------------------------------------------------
-- 9) STORAGE RLS POLICIES
--------------------------------------------------------------------------------

-- PUBLIC BUCKETS: read for everyone
create policy announcements_assets_read
on storage.objects
for select
to anon, authenticated
using (bucket_id = 'announcements');

create policy past_papers_assets_read
on storage.objects
for select
to anon, authenticated
using (bucket_id = 'past-papers');

create policy seminars_assets_read
on storage.objects
for select
to anon, authenticated
using (bucket_id = 'seminars');

-- announcements bucket uploads (permission: announcement)
create policy announcements_assets_insert
on storage.objects
for insert
to authenticated
with check (
  bucket_id = 'announcements'
  and (private.is_super_admin() or private.has_permission('announcement'))
);

create policy announcements_assets_update
on storage.objects
for update
to authenticated
using (
  bucket_id = 'announcements'
  and (private.is_super_admin() or private.has_permission('announcement'))
)
with check (
  bucket_id = 'announcements'
  and (private.is_super_admin() or private.has_permission('announcement'))
);

create policy announcements_assets_delete
on storage.objects
for delete
to authenticated
using (
  bucket_id = 'announcements'
  and (private.is_super_admin() or private.has_permission('announcement'))
);

-- past-papers bucket uploads (permission: paper_seminar)
create policy past_papers_assets_insert
on storage.objects
for insert
to authenticated
with check (
  bucket_id = 'past-papers'
  and (private.is_super_admin() or private.has_permission('paper_seminar'))
);

create policy past_papers_assets_update
on storage.objects
for update
to authenticated
using (
  bucket_id = 'past-papers'
  and (private.is_super_admin() or private.has_permission('paper_seminar'))
)
with check (
  bucket_id = 'past-papers'
  and (private.is_super_admin() or private.has_permission('paper_seminar'))
);

create policy past_papers_assets_delete
on storage.objects
for delete
to authenticated
using (
  bucket_id = 'past-papers'
  and (private.is_super_admin() or private.has_permission('paper_seminar'))
);

-- seminars bucket uploads (permission: paper_seminar)
create policy seminars_assets_insert
on storage.objects
for insert
to authenticated
with check (
  bucket_id = 'seminars'
  and (private.is_super_admin() or private.has_permission('paper_seminar'))
);

create policy seminars_assets_update
on storage.objects
for update
to authenticated
using (
  bucket_id = 'seminars'
  and (private.is_super_admin() or private.has_permission('paper_seminar'))
)
with check (
  bucket_id = 'seminars'
  and (private.is_super_admin() or private.has_permission('paper_seminar'))
);

create policy seminars_assets_delete
on storage.objects
for delete
to authenticated
using (
  bucket_id = 'seminars'
  and (private.is_super_admin() or private.has_permission('paper_seminar'))
);

-- finance-photos bucket (private: finance permission)
create policy finance_photos_read
on storage.objects
for select
to authenticated
using (
  bucket_id = 'finance-photos'
  and (private.is_super_admin() or private.has_permission('finance'))
);

create policy finance_photos_insert
on storage.objects
for insert
to authenticated
with check (
  bucket_id = 'finance-photos'
  and (private.is_super_admin() or private.has_permission('finance'))
);

create policy finance_photos_update
on storage.objects
for update
to authenticated
using (
  bucket_id = 'finance-photos'
  and (private.is_super_admin() or private.has_permission('finance'))
)
with check (
  bucket_id = 'finance-photos'
  and (private.is_super_admin() or private.has_permission('finance'))
);

create policy finance_photos_delete
on storage.objects
for delete
to authenticated
using (
  bucket_id = 'finance-photos'
  and (private.is_super_admin() or private.has_permission('finance'))
);

-- CHANGE #3: member-profiles ownership check (use owner_id if present; else owner)
do $$
declare
  has_owner_id boolean;
begin
  select exists (
    select 1
    from information_schema.columns
    where table_schema = 'storage'
      and table_name   = 'objects'
      and column_name  = 'owner_id'
  ) into has_owner_id;

  if has_owner_id then
    execute $sql$
      create policy member_profiles_read
      on storage.objects
      for select
      to authenticated
      using (
        bucket_id = 'member-profiles'
        and (
          private.is_super_admin()
          or private.has_permission('member')
          or owner_id = auth.uid()::text
        )
      )
    $sql$;

    execute $sql$
      create policy member_profiles_insert
      on storage.objects
      for insert
      to authenticated
      with check (
        bucket_id = 'member-profiles'
        and (
          private.is_super_admin()
          or private.has_permission('member')
          or owner_id = auth.uid()::text
        )
      )
    $sql$;

    execute $sql$
      create policy member_profiles_update
      on storage.objects
      for update
      to authenticated
      using (
        bucket_id = 'member-profiles'
        and (
          private.is_super_admin()
          or private.has_permission('member')
          or owner_id = auth.uid()::text
        )
      )
      with check (
        bucket_id = 'member-profiles'
        and (
          private.is_super_admin()
          or private.has_permission('member')
          or owner_id = auth.uid()::text
        )
      )
    $sql$;

    execute $sql$
      create policy member_profiles_delete
      on storage.objects
      for delete
      to authenticated
      using (
        bucket_id = 'member-profiles'
        and (
          private.is_super_admin()
          or private.has_permission('member')
          or owner_id = auth.uid()::text
        )
      )
    $sql$;

  else
    execute $sql$
      create policy member_profiles_read
      on storage.objects
      for select
      to authenticated
      using (
        bucket_id = 'member-profiles'
        and (
          private.is_super_admin()
          or private.has_permission('member')
          or owner = auth.uid()
        )
      )
    $sql$;

    execute $sql$
      create policy member_profiles_insert
      on storage.objects
      for insert
      to authenticated
      with check (
        bucket_id = 'member-profiles'
        and (
          private.is_super_admin()
          or private.has_permission('member')
          or owner = auth.uid()
        )
      )
    $sql$;

    execute $sql$
      create policy member_profiles_update
      on storage.objects
      for update
      to authenticated
      using (
        bucket_id = 'member-profiles'
        and (
          private.is_super_admin()
          or private.has_permission('member')
          or owner = auth.uid()
        )
      )
      with check (
        bucket_id = 'member-profiles'
        and (
          private.is_super_admin()
          or private.has_permission('member')
          or owner = auth.uid()
        )
      )
    $sql$;

    execute $sql$
      create policy member_profiles_delete
      on storage.objects
      for delete
      to authenticated
      using (
        bucket_id = 'member-profiles'
        and (
          private.is_super_admin()
          or private.has_permission('member')
          or owner = auth.uid()
        )
      )
    $sql$;

  end if;
end $$;

commit;
